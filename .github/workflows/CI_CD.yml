name: Makefile CI-CD

on:
  pull_request:
  push:
    branches:
      - main
  workflow_dispatch:

defaults:
  run:
    shell: bash -el {0}

env:
  CONDA_VERSION: latest
  PUBLISH_PACKAGE: false
  DIST_DIR: dist
  PYTHON_BUILD_VERSION: 3.12
  PYTHON_PACKAGE_DIST_NAME: python-package-distributions

jobs:
  verify-user:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check PR Author
        if: github.event_name == 'pull_request'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          AUTHOR=$(jq -r '.pull_request.user.login' "$GITHUB_EVENT_PATH")
          echo "PR opened by: $AUTHOR"
          TRUSTED_USERS=("KalebCoberly")
          if [[ ! " ${TRUSTED_USERS[@]} " =~ " ${AUTHOR} " ]]; then
            echo "Unauthorized user: $AUTHOR"
            exit 1
          fi

  CI:
    name: Build envs and run QC, tests, and builds.
    needs: verify-user
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
        python-version: [3.11, 3.12, 3.13]
      fail-fast: false
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Conda
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-activate-base: false
          miniconda-version: ${{ env.CONDA_VERSION }}
          python-version: ${{ matrix.python-version }}

      - name: Build Base Environment
        run: |
          BASE_ENV_NAME=basic_env_${{ matrix.os }}_${{ matrix.python-version }}
          echo "BASE_ENV_NAME=${BASE_ENV_NAME}" >> $GITHUB_ENV
          make build-env CONDA_ENV_NAME=${BASE_ENV_NAME} PYTHON_VERSION=${{ matrix.python-version }}

      # Run QC.
      # Skip 3.13 QC until msgspec releases compatible update. (pytype uses msgspec, but it doesn't work on 3.13 yet.)
      - name: Build QC Environment
        if: ${{ matrix.python-version != '3.13' && contains(matrix.os, 'ubuntu') }}
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          CONDA_ENV_NAME_QC=${PACKAGE_NAME}_qc_py${{ matrix.python-version }}_${{ matrix.os }}
          echo "CONDA_ENV_NAME_QC=${CONDA_ENV_NAME_QC}" >> $GITHUB_ENV

          conda create --name ${CONDA_ENV_NAME_QC} --clone ${{ env.BASE_ENV_NAME }}
          conda run -n ${CONDA_ENV_NAME_QC} make install INSTALL_EXTRAS=[qc]

      - name: Lint
        if: ${{ matrix.python-version != '3.13' && contains(matrix.os, 'ubuntu') }}
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_QC }} make lint

      - name: Security
        if: ${{ matrix.python-version != '3.13' && contains(matrix.os, 'ubuntu') }}
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_QC }} make security

      - name: Typecheck
        if: ${{ matrix.python-version != '3.13' && contains(matrix.os, 'ubuntu') }}
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_QC }} make typecheck

      # Run tests.
      - name: Build Test Environment
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          CONDA_ENV_NAME_TEST=${PACKAGE_NAME}_test_py${{ matrix.python-version }}_${{ matrix.os }}
          echo "CONDA_ENV_NAME_TEST=${CONDA_ENV_NAME_TEST}" >> $GITHUB_ENV

          conda create --name ${CONDA_ENV_NAME_TEST} --clone ${{ env.BASE_ENV_NAME }}
          conda run -n ${CONDA_ENV_NAME_TEST} make install INSTALL_EXTRAS=[test]

      - name: Unit Tests
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_TEST }} make unit

      - name: Integration Tests
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_TEST }} make integration

      - name: End-to-End Tests
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_TEST }} make e2e

      # Build documentation.
      - name: Build Doc Environment
        if: ${{ matrix.python-version == env.PYTHON_BUILD_VERSION && contains(matrix.os, 'ubuntu') }}
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          CONDA_ENV_NAME_DOC=${PACKAGE_NAME}_doc_py${{ matrix.python-version }}_${{ matrix.os }}
          echo "CONDA_ENV_NAME_DOC=${CONDA_ENV_NAME_DOC}" >> $GITHUB_ENV

          conda create --name ${CONDA_ENV_NAME_DOC} --clone ${{ env.BASE_ENV_NAME }}
          conda run -n ${CONDA_ENV_NAME_DOC} make install INSTALL_EXTRAS=[doc]

      - name: Build Doc
        if: ${{ matrix.python-version == env.PYTHON_BUILD_VERSION && contains(matrix.os, 'ubuntu') }}
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_DOC }} make build-doc

      # Build package and upload for release.
      - name: Build Package Environment.
        if: ${{ matrix.python-version == env.PYTHON_BUILD_VERSION && contains(matrix.os, 'ubuntu') }}
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          CONDA_ENV_NAME_BUILD=${PACKAGE_NAME}_build_py${{ matrix.python-version }}_${{ matrix.os }}
          echo "CONDA_ENV_NAME_BUILD=${CONDA_ENV_NAME_BUILD}" >> $GITHUB_ENV

          conda create --name ${CONDA_ENV_NAME_BUILD} --clone ${{ env.BASE_ENV_NAME }}
          conda run -n ${CONDA_ENV_NAME_BUILD} make install INSTALL_EXTRAS=[build]

      - name: Build Package
        if: ${{ matrix.python-version == env.PYTHON_BUILD_VERSION && contains(matrix.os, 'ubuntu') }}
        run: |
          conda run -n ${{ env.CONDA_ENV_NAME_BUILD }} make build-package DIST_DIR=${{ env.DIST_DIR }}

      - name: Upload Package
        if: ${{ matrix.python-version == env.PYTHON_BUILD_VERSION && contains(matrix.os, 'ubuntu') && env.ACT != 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.PYTHON_PACKAGE_DIST_NAME }}
          path: ${{ env.DIST_DIR }}/

  publish-to-pypi:
    name: Deploy to PyPi
    needs: [verify-user, CI]
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && github.event.inputs.ACT != 'true' }}
    runs-on: ubuntu-latest
    environment:
      name: pypi
      url: https://pypi.org/p/${{ github.repository }}
    permissions:
      id-token: write

    steps:
      - name: Download Package
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PYTHON_PACKAGE_DIST_NAME }}
          path: ${{ env.DIST_DIR }}/

      - name: Publish to PyPi
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: ${{ env.DIST_DIR }}/

  github-release:
    name: Sign distribution with Sigstore and upload to GitHub Release
    needs: publish-to-pypi
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' && github.event.inputs.ACT != 'true' }}
    runs-on: ubuntu-latest

    permissions:
      contents: write
      id-token: write

    steps:
      - name: Set up python
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_BUILD_VERSION }}

      - name: Download all the dists
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PYTHON_PACKAGE_DIST_NAME }}
          path: ${{ env.DIST_DIR }}/

      - name: Sign the dists with Sigstore
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: sigstore/gh-action-sigstore-python@v3.0.0
        with:
          inputs: >-
            ./${{ env.DIST_DIR }}/*.tar.gz
            ./${{ env.DIST_DIR }}/*.whl

      - name: Get version from dist
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        id: extract_version
        run: |
          pip install pkginfo
          tarball=$(ls ${{ env.DIST_DIR }}/*.tar.gz | head -n 1)
          wheel=$(ls ${{ env.DIST_DIR }}/*.whl | head -n 1)
          if [ -f "$tarball" ]; then
            version=$(python -c "import pkginfo; info = pkginfo.get_metadata('$tarball'); print(info.version)")
          elif [ -f "$wheel" ]; then
            version=$(python -c "import pkginfo; info = pkginfo.get_metadata('$wheel'); print(info.version)")
          else
            echo "No distribution files found."
            exit 1
          fi
          echo "VERSION=$version" >> $GITHUB_ENV

      - name: Create GitHub Release
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: >-
          gh release create
          'v${{ env.VERSION }}'
          --repo '${{ github.repository }}'
          --notes ""

      - name: Upload artifact signatures to GitHub Release
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: >-
          gh release upload
          '${{ github.ref_name }}' ${{ env.DIST_DIR }}/**
          --repo '${{ github.repository }}'

  publish-to-testpypi:
    name: Publish to TestPyPI
    needs: [verify-user, CI]
    if: ${{ github.event_name == 'workflow_dispatch' && github.actor == 'KalebCoberly' && github.event.inputs.ACT != 'true' }}
    runs-on: ubuntu-latest

    environment:
      name: testpypi
      url: https://test.pypi.org/p/bfb_delivery

    permissions:
      id-token: write

    steps:
      - name: Download all the dists
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.PYTHON_PACKAGE_DIST_NAME }}
          path: ${{ env.DIST_DIR }}/

      - name: Publish to TestPyPI
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          repository-url: https://test.pypi.org/legacy/

  test_published_package_prod:
    name: Test Published Package on PyPi
    needs: publish-to-pypi
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/checkout@v4

      - name: Setup Conda
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-activate-base: false
          miniconda-version: ${{ env.CONDA_VERSION }}
          python-version: ${{ env.PYTHON_BUILD_VERSION }}

      - name: Build Environment
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          ENV_NAME=test_publish_to_pypi
          echo "ENV_NAME=${ENV_NAME}" >> $GITHUB_ENV
          conda create -n ${ENV_NAME} python=${{ env.PYTHON_BUILD_VERSION }} -y

      - name: Install Package
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          PACKAGE_NAME_HYPHEN=$(echo ${PACKAGE_NAME} | tr '_' '-')
          PACKAGE_VERSION=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['version'])")
          conda run -n ${{ env.ENV_NAME }} pip install ${PACKAGE_NAME_HYPHEN}==${PACKAGE_VERSION}

      - name: Run Tests
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          # Quick test to make sure the package is importable before installing anything else.
          conda activate ${{ env.ENV_NAME }}
          python -c "import ${{ env.PACKAGE_NAME }}"
          pip install pytest
          pytest tests/

  test_published_package_test:
    name: Test Published Package on TestPyPi
    needs: publish-to-testpypi
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: actions/checkout@v4

      - name: Setup Conda
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        uses: conda-incubator/setup-miniconda@v3
        with:
          auto-activate-base: false
          miniconda-version: ${{ env.CONDA_VERSION }}
          python-version: ${{ env.PYTHON_BUILD_VERSION }}

      - name: Build Environment
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          ENV_NAME=test_publish_to_testpypi
          echo "ENV_NAME=${ENV_NAME}" >> $GITHUB_ENV
          conda create -n ${ENV_NAME} python=${{ env.PYTHON_BUILD_VERSION }} -y

      - name: Install Package
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          PACKAGE_NAME=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['name'])")
          echo "PACKAGE_NAME=${PACKAGE_NAME}" >> $GITHUB_ENV
          PACKAGE_NAME_HYPHEN=$(echo ${PACKAGE_NAME} | tr '_' '-')
          PACKAGE_VERSION=$(python -c "import configparser; cfg = configparser.ConfigParser(); cfg.read('setup.cfg'); print(cfg['metadata']['version'])")
          conda run -n ${{ env.ENV_NAME }} pip install -i https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ ${PACKAGE_NAME_HYPHEN}==${PACKAGE_VERSION}

      - name: Run Tests
        if: ${{ env.PUBLISH_PACKAGE == 'true' }}
        run: |
          # Quick test to make sure the package is importable before installing anything else.
          conda activate ${{ env.ENV_NAME }}
          python -c "import ${{ env.PACKAGE_NAME }}"
          pip install pytest
          pytest tests/
